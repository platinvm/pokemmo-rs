mod client_hello;
mod client_ready;
mod server_hello;

pub use self::client_hello::ClientHello;
pub use self::client_ready::ClientReady;
pub use self::server_hello::Checksum;
pub use self::server_hello::ServerHello;

/// The `Message` trait defines serialization and deserialization for protocol message payloads.
///
/// Message types are distinct from codec types: a message is the payload of a codec variant.
/// Implementations are typically generated by the `#[derive(Message)]` procedural macro.
///
/// All primitive integer types are encoded as little-endian bytes. Variable-length fields
/// like `Vec<u8>` require a length prefix, specified via the `#[prefixed(T)]` attribute.
///
/// ## Examples
///
/// ```ignore
/// use pokemmo::message::{Message, ClientHello};
///
/// let msg = ClientHello::new(42, std::time::SystemTime::now(), 123, 456)?;
/// let bytes = msg.serialize()?;
/// let decoded = ClientHello::deserialize(&bytes)?;
/// ```
pub trait Message: Sized {
    /// Serializes this message into a byte vector.
    ///
    /// Integer fields are encoded as little-endian. Fields marked with `#[prefixed(T)]`
    /// are encoded as `[length_prefix, data...]` where `length_prefix` is of type `T`.
    ///
    /// ## Errors
    ///
    /// Returns an error if I/O operations fail or data sizes exceed representable ranges.
    fn serialize(&self) -> std::io::Result<Vec<u8>>;

    /// Deserializes a byte slice into this message type.
    ///
    /// The byte layout must match the structure expected by the implementation.
    /// All fields are consumed in order; extra data is ignored.
    ///
    /// ## Errors
    ///
    /// Returns an error if:
    /// - The data is truncated and insufficient bytes remain.
    /// - A prefixed length exceeds the maximum allowed size.
    /// - Integer conversions fail (e.g., invalid byte sequences).
    fn deserialize(data: &[u8]) -> std::io::Result<Self>;
}

pub use pokemmo_macros::Message;
